<html>
<head>
<script src="./construit-fgeo.js"></script>
</head>
<body style="width: 100%; height: 100%">
<script>
	// Ported from Stefan Gustavson's java implementation
// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
// Read Stefan's excellent paper for details on how this code works.
//
// Sean McCullough banksean@gmail.com

/**
 * You can pass in a random number generator object if you like.
 * It is assumed to have a random() method.
 */
var ClassicalNoise = function(r) { // Classic Perlin noise in 3D, for comparison 
	if (r == undefined) r = Math;
  this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0], 
                                 [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1], 
                                 [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]]; 
  this.p = [];
  for (var i=0; i<256; i++) {
	  this.p[i] = Math.floor(r.random()*256);
  }
  // To remove the need for index wrapping, double the permutation table length 
  this.perm = []; 
  for(var i=0; i<512; i++) {
		this.perm[i]=this.p[i & 255];
  }
};

ClassicalNoise.prototype.dot = function(g, x, y, z) { 
    return g[0]*x + g[1]*y + g[2]*z; 
};

ClassicalNoise.prototype.mix = function(a, b, t) { 
    return (1.0-t)*a + t*b; 
};

ClassicalNoise.prototype.fade = function(t) { 
    return t*t*t*(t*(t*6.0-15.0)+10.0); 
};

  // Classic Perlin noise, 3D version 
ClassicalNoise.prototype.noise = function(x, y, z) { 
  // Find unit grid cell containing point 
  var X = Math.floor(x); 
  var Y = Math.floor(y); 
  var Z = Math.floor(z); 
  
  // Get relative xyz coordinates of point within that cell 
  x = x - X; 
  y = y - Y; 
  z = z - Z; 
  
  // Wrap the integer cells at 255 (smaller integer period can be introduced here) 
  X = X & 255; 
  Y = Y & 255; 
  Z = Z & 255;
  
  // Calculate a set of eight hashed gradient indices 
  var gi000 = this.perm[X+this.perm[Y+this.perm[Z]]] % 12; 
  var gi001 = this.perm[X+this.perm[Y+this.perm[Z+1]]] % 12; 
  var gi010 = this.perm[X+this.perm[Y+1+this.perm[Z]]] % 12; 
  var gi011 = this.perm[X+this.perm[Y+1+this.perm[Z+1]]] % 12; 
  var gi100 = this.perm[X+1+this.perm[Y+this.perm[Z]]] % 12; 
  var gi101 = this.perm[X+1+this.perm[Y+this.perm[Z+1]]] % 12; 
  var gi110 = this.perm[X+1+this.perm[Y+1+this.perm[Z]]] % 12; 
  var gi111 = this.perm[X+1+this.perm[Y+1+this.perm[Z+1]]] % 12; 
  
  // The gradients of each corner are now: 
  // g000 = grad3[gi000]; 
  // g001 = grad3[gi001]; 
  // g010 = grad3[gi010]; 
  // g011 = grad3[gi011]; 
  // g100 = grad3[gi100]; 
  // g101 = grad3[gi101]; 
  // g110 = grad3[gi110]; 
  // g111 = grad3[gi111]; 
  // Calculate noise contributions from each of the eight corners 
  var n000= this.dot(this.grad3[gi000], x, y, z); 
  var n100= this.dot(this.grad3[gi100], x-1, y, z); 
  var n010= this.dot(this.grad3[gi010], x, y-1, z); 
  var n110= this.dot(this.grad3[gi110], x-1, y-1, z); 
  var n001= this.dot(this.grad3[gi001], x, y, z-1); 
  var n101= this.dot(this.grad3[gi101], x-1, y, z-1); 
  var n011= this.dot(this.grad3[gi011], x, y-1, z-1); 
  var n111= this.dot(this.grad3[gi111], x-1, y-1, z-1); 
  // Compute the fade curve value for each of x, y, z 
  var u = this.fade(x); 
  var v = this.fade(y); 
  var w = this.fade(z); 
   // Interpolate along x the contributions from each of the corners 
  var nx00 = this.mix(n000, n100, u); 
  var nx01 = this.mix(n001, n101, u); 
  var nx10 = this.mix(n010, n110, u); 
  var nx11 = this.mix(n011, n111, u); 
  // Interpolate the four results along y 
  var nxy0 = this.mix(nx00, nx10, v); 
  var nxy1 = this.mix(nx01, nx11, v); 
  // Interpolate the two last results along z 
  var nxyz = this.mix(nxy0, nxy1, w); 

  return nxyz; 
};
</script>
<script>
	
	var tracer;

	function quaternion(x,y,z) {
		const lvalue = 0.0;
		var q1,q2,q3,q4, i, temp, length;
		q1 = x;
		q2 = y;
		q3 = z;
		q4 = lvalue;

		const c1 = -1.0;
		const c2 = -0.13;
		const c3 = 0.0;
		const c4 = 0.0;

		const bailout = 4.0;
		const maxiter = 8;
		var bailoutsq = bailout*bailout;

		 for (i=0; i<maxiter; i++) {
			temp = 2.0 * q1;
			q1 = Math.pow(q1,2) - Math.pow(q2,2) - Math.pow(q3,2) - Math.pow(q4,2) + c1;
			q2 = (temp * q2) + c2;
			q3 = (temp * q3) + c3;
			q4 = (temp * q4) + c4;
			length = Math.pow(q1,2) + Math.pow(q2,2) + Math.pow(q3,2) + Math.pow(q4,2);
			if (length > bailoutsq) {
			   break;
			}
		 }

		return Math.sqrt(length) - bailout;
	}

	let c = 1.8585;

	function decocube(x,y,z) {
		const c = 1.8585;
		//const c = 0.82;
		let x2 = x*x;
		let y2 = y*y;
		let z2 = z*z;
		return 0.02 - (Math.pow(x2 + y2 - c, 2) + Math.pow(z2 - 1, 2)) *
			(Math.pow(y2 + z2 - c, 2) + Math.pow(x2 - 1, 2)) *
			(Math.pow(x2 + z2 - c, 2) + Math.pow(y2 - 1, 2));			
	}

	function CSGUnion(a,b) {
		return Math.max(a,b);
	}

	function CSGSubtract(a,b) {
		return Math.min(a,-b);
	}

	function CSGSphere(x, center, R) {
		var x0, x1, x2;
		x0 = x[0] - center[0];
		x1 = x[1] - center[1];
		x2 = x[2] - center[2];
		return (R*R) - (x0*x0) - (x1*x1) - (x2*x2);
	}

	function CSGBlendUni(f1,f2,a0,a1,a2) {
		var uni,f1a1,f2a2,disp;
		uni = f1 + f2 + Math.sqrt(f1*f1+f2*f2);
		f1a1 = f1 / a1;
		f2a2 = f2 / a2;
		disp = a0 / (1 + f1a1*f1a1 + f2a2*f2a2);
		return uni + disp;
	}

	function pooh(i,j,k) {
		const x = [i,j,k];
		const sphere1 = CSGSphere(x, [0.0,0.0,0.0], 6.0);
		const sphere2 = CSGSphere(x, [0,0,-6.0], 2.0);
		//const ear1 = CSGSphere(x, [-0.0934,-4.6164,4.1060], 2.0);
		//const ear2 = CSGSphere(x, [-1.1968,-3.9183,-4.1060], 2.0);
		const body = CSGSubtract(sphere1,sphere2);
		return body; //CSGBlendUni(CSGUnion(ear1,ear2),body, 2,2,3);
	}

	function redraw(x,y,z,rx,ry,rz) {
		const mat4 = Construit.fgeo.glmatrix.mat4;
		const vec3 = Construit.fgeo.glmatrix.vec3;

		var output = document.getElementById("output");

		var mmatrix = mat4.create();
		mat4.identity(mmatrix);

		var rot = vec3.create();
		vec3.set(rot, 1, 0, 0);
		mat4.rotate(mmatrix, mmatrix, rx * Math.PI / 180, rot);
		vec3.set(rot, 0, 1, 0);
		mat4.rotate(mmatrix, mmatrix, ry * Math.PI / 180, rot);
		vec3.set(rot, 0, 0, 1);
		mat4.rotate(mmatrix, mmatrix, rz * Math.PI / 180, rot);

		var translation = vec3.create();
		vec3.set (translation, x, y, z);
		mat4.translate(mmatrix,mmatrix,translation);

		tracer.render(decocube, mmatrix);


		/*Construit.fgeo.trace(output, pooh,
			{boundary: [-6,6], depthResolution: 200, fov: 45, sample: 8, progressive: true,
				matrix: mmatrix}
		);*/

		/*Construit.fgeo.trace(output, quaternion,
			{boundary: [-200.0,200.0], depthResolution: 100, fov: 45, sample: 8, progressive: true,
				matrix: mmatrix}
		);*/
	}
	
	window.onload = function() {
		tracer = new Construit.fgeo(output, {
			boundary: [-1.5,1.5],
			depthResolution: 100,
			fov: 45,
			sample: 8,
			progressive: false,
			lod: 0.95
		});

		noise = new ClassicalNoise();

		tracer.setTexture(function(x,y,z) {
			var n = (noise.noise(x*5,y*5,z*5)+1.0) / 2.0;
			n = ((1 + Math.sin((x + n/2) * 50)) / 2)*255;
			return [n,n*0.8,n*0.8];
			//return [255,0,0];
		});

		var rotation = 60;
		var cdir = true;

		redraw(0,0,-3.5,0,rotation,0);
		/*setInterval(function() {
			rotation += 2;
			if (cdir) c -= 0.1;
			else c += 0.1;
			if (c <= 0.5) cdir = false;
			else if (c >= 2.0) cdir = true;
			redraw(0,0,-3.5,0,rotation,0);
		}, 100);*/
	}
</script>
<canvas width="512" height="512" id="output"></canvas>
</body>
</html>
